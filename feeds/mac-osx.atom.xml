<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Saevon.ca</title><link href="//blog.saevon.ca/" rel="alternate"></link><link href="/feeds/mac-osx.atom.xml" rel="self"></link><id>//blog.saevon.ca/</id><updated>2015-08-14T00:00:00-04:00</updated><entry><title>Quickly pausing an app in Mac-OS</title><link href="//blog.saevon.ca/coding/quickly-pausing-an-app-in-mac-os/" rel="alternate"></link><updated>2015-08-14T00:00:00-04:00</updated><author><name>Saevon</name></author><id>tag://blog.saevon.ca,2015-08-14:coding/quickly-pausing-an-app-in-mac-os/</id><summary type="html">&lt;p&gt;Chrome has always annoyed me when my battery is low, or when I'm low on memory. So I made a quick terminal command that freezes its processes. Of course I use this for pausing any of my apps.&lt;/p&gt;
&lt;section class="&amp;quot;section section1&amp;quot;" id="overview"&gt;&lt;h1&gt;Overview&lt;/h1&gt;
&lt;p&gt;&lt;div class="alert alert-info "&gt;&lt;i class="fa fa-info-circle"&gt;&lt;/i&gt;
You can see the code in my config file repository, along with my other bash aliases.
&lt;a href="bash-pauser"&gt;Click here to see the entire pause script&lt;/a&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;I added the following bash functions&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pause_process(pid)&lt;/code&gt;: nicer kill command that pauses a process (&lt;code&gt;kill -STOP&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pause_app(string)&lt;/code&gt;: searches for any proccesses with the given string, pausing them all&lt;/p&gt;
&lt;p&gt;As well as the opposing functions &lt;code&gt;resume_app()&lt;/code&gt; and &lt;code&gt;resume_process()&lt;/code&gt; (which use &lt;code&gt;kill -CONT&lt;/code&gt;).&lt;/p&gt;
&lt;section class="&amp;quot;section section2&amp;quot;" id="implementation"&gt;&lt;h2&gt;Implementation&lt;/h2&gt;
&lt;p&gt;&lt;div class="alert alert-info "&gt;&lt;i class="fa fa-commenting"&gt;&lt;/i&gt;
I'm not too great at bash, so if there's a better way to do this, do comment!
Thanks!
&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;First thing I needed was a nice way to work with lists in bash, so I made a function to map a command on each item.
Using that I made a function that searches for processes that contain a given string. Then it maps a command on them&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;function &lt;/span&gt;map&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;for &lt;/span&gt;pid in &lt;span class="sb"&gt;`&lt;/span&gt;&lt;span class="nb"&gt;eval&lt;/span&gt; &lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;; &lt;span class="k"&gt;do&lt;/span&gt;
        &lt;span class="nv"&gt;$2&lt;/span&gt; &lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;pid&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;;
    &lt;span class="k"&gt;done&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="nv"&gt;PGREP_FLAGS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;-U ${USER}&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;function &lt;/span&gt;search_map&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    map &lt;span class="s2"&gt;&amp;quot;pgrep ${PGREP_FLAGS} -f \&amp;quot;$1\&amp;quot;&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;$2&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Using this the &lt;code&gt;pause_app()&lt;/code&gt; command is quite simple, and the resume_app one as well.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;function &lt;/span&gt;pause_app&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="nb"&gt;echo &lt;/span&gt;pausing &lt;span class="nv"&gt;$1&lt;/span&gt;
    search_map &lt;span class="s2"&gt;&amp;quot;$1&amp;quot;&lt;/span&gt; pause_process;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/section&gt;&lt;section class="&amp;quot;section section2&amp;quot;" id="usage"&gt;&lt;h2&gt;Usage&lt;/h2&gt;
&lt;p&gt;Using this just requires knowing part of the app name:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;pause_app Chrome.app
pausing Chrome.app
  pausing:  378
  pausing:  406
  pausing:  414
&lt;span class="nv"&gt;$ &lt;/span&gt;resume_app Chrome.app
resuming Chrome.app
  resuming:  378
  resuming:  406
  resuming:  414
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;div class="alert alert-warning "&gt;&lt;i class="fa fa-warning"&gt;&lt;/i&gt;
&lt;code&gt;pgrep&lt;/code&gt; will find more that one app if they contain the same text in the process tag.
The best search string is one which contains the entire app name, (or at least the &lt;code&gt;.app&lt;/code&gt; prefix)
&lt;/div&gt;&lt;/p&gt;
&lt;/section&gt;&lt;section class="&amp;quot;section section2&amp;quot;" id="more-uses"&gt;&lt;h2&gt;More Uses&lt;/h2&gt;
&lt;p&gt;I've also made a bash script that freezes all the processes I consider extraneous to give my computer some resources during clinch moments. &lt;code&gt;pause_all&lt;/code&gt; reads a list of app names, mapping the pause script on them all. &lt;code&gt;resume_all&lt;/code&gt; does the opposite. You can see it &lt;a href="https://github.com/Saevon/config/blob/master/bash/pauser_template.bash"&gt;here&lt;/a&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/section&gt;&lt;section class="&amp;quot;section section1&amp;quot;" id="reference"&gt;&lt;h1&gt;Reference&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Saevon/config/blob/master/bash/pauser.bash"&gt;The entire pause Script&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Saevon/config/blob/master/bash/pauser_template.bash"&gt;Pausing a list of apps at once&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;</summary><category term="Mac OSX"></category><category term="bash"></category></entry><entry><title>Using the proper Assembler on Mac OSX</title><link href="//blog.saevon.ca/coding/using-the-proper-assembler-on-mac-osx/" rel="alternate"></link><updated>2014-06-20T00:00:00-04:00</updated><author><name>Saevon</name></author><id>tag://blog.saevon.ca,2014-06-20:coding/using-the-proper-assembler-on-mac-osx/</id><summary type="html">&lt;p&gt;The standard compiler &lt;code&gt;gcc&lt;/code&gt; for Mac OSX is actually the &lt;code&gt;clang&lt;/code&gt; compiler, this means that you need to use its assembler and linker as well. If you try to do the compilation in steps, you will notice that "&lt;code&gt;as&lt;/code&gt;" is not the clang assembler however, which causes it to break down.&lt;/p&gt;
&lt;p&gt;In this article I will discuss a simple solution to this problem.&lt;/p&gt;
&lt;section class="&amp;quot;section section1&amp;quot;" id="intro"&gt;&lt;h1&gt;Intro&lt;/h1&gt;
&lt;p&gt;&lt;div class="alert alert-info "&gt;&lt;i class="fa fa-info-circle"&gt;&lt;/i&gt;
Jump straight to the &lt;a href="#solution"&gt;solution&lt;/a&gt;, or read about the situation ahead.
&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;I was working on a microkernel &lt;code&gt;(CS 452: Real Time Programming)&lt;/code&gt;, and I needed to do my compilations with a custom compiler, assembler and linker, so I could compile for ARM. However this required me to use an older version of gcc without the &lt;code&gt;--with-as=&lt;/code&gt; flag, thus I needed to get the assembler to run as a seperate command.&lt;/p&gt;
&lt;p&gt;Enter a complication: I needed this to run tests on my local machine (Mac), as well as on those of my partners (Windows running cygwin), I also needed this to compile on a remote Linux server, which could do the necessary cross-compilation.&lt;/p&gt;
&lt;p&gt;My resulting makefile had the following basic structure.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# Create the assembly file so that we can use a seperate assembler in the next step&lt;/span&gt;
&lt;span class="nf"&gt;%.s&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="m"&gt;%.c&lt;/span&gt;
    &lt;span class="k"&gt;$(&lt;/span&gt;CC&lt;span class="k"&gt;)&lt;/span&gt; -S &lt;span class="k"&gt;$(&lt;/span&gt;CFLAGS&lt;span class="k"&gt;)&lt;/span&gt; -o &lt;span class="nv"&gt;$@&lt;/span&gt; &lt;span class="nv"&gt;$&amp;lt;&lt;/span&gt;

&lt;span class="c"&gt;# Use out assembler to compile an object file&lt;/span&gt;
&lt;span class="nf"&gt;%.o&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="m"&gt;%.s&lt;/span&gt;
    &lt;span class="k"&gt;$(&lt;/span&gt;AS&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;ASFLAGS&lt;span class="k"&gt;)&lt;/span&gt; -o &lt;span class="nv"&gt;$@&lt;/span&gt; &lt;span class="nv"&gt;$&amp;lt;&lt;/span&gt;

&lt;span class="c"&gt;# Combine the object files using the linker&lt;/span&gt;
&lt;span class="nf"&gt;%.elf&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="m"&gt;%.o&lt;/span&gt;
    &lt;span class="k"&gt;$(&lt;/span&gt;LD&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;LDFLAGS&lt;span class="k"&gt;)&lt;/span&gt; -Map &lt;span class="nv"&gt;$*&lt;/span&gt;.map -o &lt;span class="nv"&gt;$@&lt;/span&gt; &lt;span class="nv"&gt;$*&lt;/span&gt;.o &lt;span class="k"&gt;$(&lt;/span&gt;INC&lt;span class="k"&gt;)&lt;/span&gt; -lgcc
    chmod a+r &lt;span class="nv"&gt;$@&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;First we generate the assembly files, next we assemble the resulting files into object files. Finally we produce the elf file that will represent my Kernel.&lt;/p&gt;
&lt;p&gt;This will run properly on the linux machine, however when I try to use the same makefile to generate code locally, it fails.&lt;/p&gt;
&lt;/section&gt;&lt;section class="&amp;quot;section section1&amp;quot;" id="solution"&gt;&lt;h1&gt;Solution&lt;/h1&gt;
&lt;p&gt;The error I get looks like this.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;test_cbuf&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;Unknown&lt;/span&gt; &lt;span class="n"&gt;pseudo&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cfi_startproc&lt;/span&gt;
&lt;span class="n"&gt;test_cbuf&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;Unknown&lt;/span&gt; &lt;span class="n"&gt;pseudo&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cfi_def_cfa_offset&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So the assemble results from &lt;code&gt;gcc&lt;/code&gt; can't be read by the assembler?&lt;/p&gt;
&lt;p&gt;It seems the &lt;code&gt;gcc&lt;/code&gt; and the &lt;code&gt;as&lt;/code&gt; progams that Mac has by default use differing standards.&lt;/p&gt;
&lt;p&gt;The correct assembler to use uses a command like the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;clang -c -x assembler &lt;span class="nv"&gt;$@&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;p&gt;Now to solve my situation above:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;I can give a different &lt;code&gt;AS = "clang -c -x assembler"&lt;/code&gt; variable to my makefile&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;But then I either need to call it that way always (a pain) or add different instructions&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I can add a simple bash script that calls the code above, one that is earlier in my &lt;code&gt;$PATH&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I opted for the second solution, mostly since this seems to be a more common use-case for me.&lt;/p&gt;
&lt;/section&gt;</summary><category term="Mac OSX"></category><category term="assembler"></category><category term="clang"></category><category term="Real-Time (Trains)"></category></entry></feed>